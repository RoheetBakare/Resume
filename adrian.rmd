flog.prior= function(alpha,lambda) {

f =-3*lgamma(alpha)+alpha*log(lambda[1]*lambda[2]*lambda[3])-alpha/100      

return(f)                                                              

}

y1 = c(86, 74, 79, 70, 84, 65, 57, 49, 70, 79)

y2 = c(83, 68, 59, 70, 58, 66, 64, 70, 69, 75)

y3 = c(72, 84, 72, 89, 88, 91, 74, 94, 77, 76)

y.bar = (mean(y1)+mean(y2)+ mean(y3))/3

y.sum = numeric(3)

y.sum[1] = sum(y1); y.sum[2] = sum(y2); y.sum[3] = sum(y3)

n = length(y1)

#

N = 5000

B = 1000

N1 = N+1

lambda = matrix(0,N1,3)

lambda[1,] = c(mean(y1),mean(y2),mean(y3))

alpha = c()

alpha[1] = 100 # 100 since prior of exp(alpha/100) has a mean of 100

d = 10 # be the distance of sequence of points for the assign variable

accept= 0

for(i in 1:N)

{

	

	for(j in 1:3)

	

	{

		lambda[i+1,j]=rgamma(1, y.sum[i] + alpha[i], n+1)  # initial alpha but in the components to check on for to condition;

	}

	alpha.star=-1

	while(alpha.star < 0)

	{

		alpha.star=rnorm(1, alpha[i],d)

	}

	f.star=flog.prior(alpha.star,lambda[i+1, ])

	f.i=flog.prior(alpha[i],lambda[i+1, ] )

	if (runif(1) <= min(1, exp(f.star - f.i)) 

	{

		alpha[i+1]=alpha.star

		accept=accept + 1 

	}

	

	else

	 alpha[i+1]=alpha[i]

}

accept/ N

flog.prior= function(alpha,lambda) {
+ f =-3*lgamma(alpha)+alpha*log(lambda[1]*lambda[2]*lambda[3])-alpha/100      
+ return(f)                                                              
+ }
> y1 = c(86, 74, 79, 70, 84, 65, 57, 49, 70, 79)
> y2 = c(83, 68, 59, 70, 58, 66, 64, 70, 69, 75)
> y3 = c(72, 84, 72, 89, 88, 91, 74, 94, 77, 76)
> y.bar = (mean(y1)+mean(y2)+ mean(y3))/3
> y.sum = numeric(3)
> y.sum[1] = sum(y1); y.sum[2] = sum(y2); y.sum[3] = sum(y3)
> n = length(y1)
> #
> N = 5000
> B = 1000
> N1 = N+1
> lambda = matrix(0,N1,3)
> lambda[1,] = c(mean(y1),mean(y2),mean(y3))
> alpha = c()
> alpha[1] = 100 # 100 since prior of exp(alpha/100) has a mean of 100
> d = 10 # be the distance of sequence of points for the assign variable
> accept= 0
> for(i in 1:N)
+ {
+ for(j in 1:3)
+ {
+ lambda[i+1,j]=rgamma(1, y.sum[i] + alpha[i], n+1)  # initial alpha but in the components to check on for to condition;
+ }
+ alpha.star=-1
+ while(alpha.star < 0)
+ {
+ alpha.star=rnorm(1, alpha[i],d)
+ }
+ f.star=flog.prior(alpha.star,lambda[i+1, ])
+ f.i=flog.prior(alpha[i],lambda[i+1, ] )
+ if (runif(1) <= min(1, exp(f.star-f.i)))
+ {
+ alpha[i+1]=alpha.star
+ accept=accept + 1
+ }else alpha[i+1]=alpha[i]
+ }
Error in if (runif(1) <= min(1, exp(f.star - f.i))) { :
  missing value where TRUE/FALSE needed
In addition: Warning messages:
1: In rgamma(1, y.sum[i] + alpha[i], n + 1) : NAs produced
2: In rgamma(1, y.sum[i] + alpha[i], n + 1) : NAs produced
3: In rgamma(1, y.sum[i] + alpha[i], n + 1) : NAs produced
> accept/ N
